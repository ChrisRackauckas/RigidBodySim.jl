var documenterSearchIndex = {"docs":
[{"location":"#RigidBodySim-1","page":"Home","title":"RigidBodySim","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"RigidBodySim provides Julia tools for simulation and visualization of systems of interconnected rigid bodies.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"RigidBodySim is mainly built on top of the following packages:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"RigidBodyDynamics for construction of rigid body dynamics mechanisms and evaluation of their dynamics.\nDifferentialEquations packages, for numerical integration of the differential equations.\nMeshCatMechanisms for visualization.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"RigidBodySim does not attempt to abstract away its dependence on these packages, as doing so would necessarily expose only a subset of their functionality, and would require users familiar with these packages to learn yet another API. Instead, RigidBodySim simply plugs into existing functionality, providing convenience methods and extensions. Only this additional functionality is documented here, and we refer to the documentation for these packages for further information:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"RigidBodyDynamics: (Image: Stable)\nDifferentialEquations: (Image: Stable)\nMeshCatMechanisms: Readme","category":"page"},{"location":"#Functionality-1","page":"Home","title":"Functionality","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"RigidBodySim currently provides the following key features:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Convenient creation of DiffEqBase.ODEProblems given a RigidBodyDynamics.MechanismState and, optionally, a controller.\nIntegration with MeshCatMechanisms for visualization, both during simulation and after. The visualizer window can also control (currently, pause or terminate) the simulation.\nEasy simulation of a digital controller running at a fixed rate (see PeriodicController).","category":"page"},{"location":"#Performance-1","page":"Home","title":"Performance","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Performance is fairly good. For example, we have used RigidBodySim to perform a 10-second simulation of the humanoid robot Atlas (v5) standing on flat ground with a controller running at 100 Hz in 13 seconds with the Tsitouras 5/4 variable-step integrator on a 3GHz machine.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#Installing-Julia-1","page":"Home","title":"Installing Julia","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Download links and more detailed instructions are available on the Julia website. The latest release of RigidBodySim.jl requires at least version 0.7 of Julia.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"warning: Warning\nDo not use apt-get or brew to install Julia, as the versions provided by these package managers tend to be out of date.","category":"page"},{"location":"#Installing-RigidBodySim-1","page":"Home","title":"Installing RigidBodySim","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"To install the latest tagged release of RigidBodySim, simply run","category":"page"},{"location":"#","page":"Home","title":"Home","text":"import Pkg\nPkg.add(\"RigidBodySim\")","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To check out the master branch and work on the bleeding edge (generally, not recommended), additionally run","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pkg.checkout(\"RigidBodySim\")","category":"page"},{"location":"#First-steps-1","page":"Home","title":"First steps","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"To load the package, use the command:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using RigidBodySim","category":"page"},{"location":"#","page":"Home","title":"Home","text":"It is recommended to follow the quick start guide to get up to speed.","category":"page"},{"location":"#Contents-1","page":"Home","title":"Contents","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n  \"quickstart.md\",\n  \"details.md\"\n]\nDepth = 2","category":"page"},{"location":"#Citing-this-library-1","page":"Home","title":"Citing this library","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"@misc{rigidbodysimjl,\n author = \"Twan Koolen, Robin Deits, and contributors\",\n title = \"RigidBodySim.jl\",\n year = 2016,\n url = \"https://github.com/JuliaRobotics/RigidBodySim.jl\"\n}","category":"page"},{"location":"quickstart/#quickstart-1","page":"Quick start guide","title":"Quick start guide","text":"","category":"section"},{"location":"quickstart/#","page":"Quick start guide","title":"Quick start guide","text":"To get started, see this Jupyter notebook. To run it locally, you'll need the IJulia package.","category":"page"},{"location":"details/#Details-1","page":"Details","title":"Details","text":"","category":"section"},{"location":"details/#ODE-problem-creation-1","page":"Details","title":"ODE problem creation","text":"","category":"section"},{"location":"details/#","page":"Details","title":"Details","text":"Dynamics","category":"page"},{"location":"details/#RigidBodySim.Core.Dynamics","page":"Details","title":"RigidBodySim.Core.Dynamics","text":"Dynamics(mechanism)\nDynamics(mechanism, control!; setparams!)\n\n\nCreate a Dynamics object, representing either the passive or closed-loop dynamics of a RigidBodyDynamics.Mechanism.\n\nThe control! argument is a callable with the signature control!(τ, t, state), where τ is the torque vector to be set in the body of control!, t is the current time, and state is a MechanismState object. By default, control! is zero_control! (resulting in the passive dynamics).\n\nThe setparams! keyword argument is a callable with the signature setparams!(state, p) where state is a MechanismState and p is a vector of parameters, as used in OrdinaryDiffEq.jl.\n\n\n\n\n\n","category":"type"},{"location":"details/#","page":"Details","title":"Details","text":"ODEProblem(::RigidBodySim.Dynamics, ::Union{Base.AbstractVector, RigidBodyDynamics.MechanismState}, tspan)","category":"page"},{"location":"details/#DiffEqBase.ODEProblem-Tuple{Dynamics,Union{AbstractArray{T,1} where T, MechanismState},Any}","page":"Details","title":"DiffEqBase.ODEProblem","text":"ODEProblem(dynamics, x0, tspan)\nODEProblem(dynamics, x0, tspan, p; callback, kwargs...)\n\n\nCreate a DiffEqBase.ODEProblem associated with the dynamics of a RigidBodyDynamics.Mechanism.\n\nThe initial state x0 can be either a RigidBodyDynamics.MechanismState), or an AbstractVector containing the initial state represented as [q; v; s], where q is the configuration vector, v is the velocity vector, and s is the vector of additional states.\n\nThe callback keyword argument can be used to pass in additional DifferentialEquations.jl callbacks.\n\n\n\n\n\n","category":"method"},{"location":"details/#control-1","page":"Details","title":"Control","text":"","category":"section"},{"location":"details/#","page":"Details","title":"Details","text":"zero_control!\ncontrolcallback\nPeriodicController\nSumController","category":"page"},{"location":"details/#RigidBodySim.Core.zero_control!","page":"Details","title":"RigidBodySim.Core.zero_control!","text":"zero_control!(τ, t, state)\n\n\nA 'zero' controller, i.e. one that sets all control torques to zero at all times.\n\n\n\n\n\n","category":"function"},{"location":"details/#RigidBodySim.Core.controlcallback","page":"Details","title":"RigidBodySim.Core.controlcallback","text":"controlcallback(control!)\n\n\nCan be used to create a callback associated with a given controller.\n\n\n\n\n\n","category":"function"},{"location":"details/#RigidBodySim.Control.PeriodicController","page":"Details","title":"RigidBodySim.Control.PeriodicController","text":"struct PeriodicController{Tau<:(AbstractArray{T,1} where T), T<:Number, C, I}\n\nA PeriodicController can be used to simulate a digital controller that runs at a fixed rate (in terms of simulation time). It does so by performing a zero-order hold on a provided control function.\n\nPeriodicControllers can be constructed using\n\nPeriodicController(τ, Δt, control!; initialize = DiffEqBase.INITIALIZE_DEFAULT, save_positions = (false, false))\n\nwhere control! is a controller satisfying the standard RigidBodySim controller signature (control!(τ, Δt, state)), Δt is the simulation time interval between calls to the control! function, and τ is used to call control!. The initialize and save_positions keyword arguments are documented in the DiscreteCallback section of the DifferentialEquations documentation.\n\nPeriodicControllers are callable objects, and themselves fit the standard RigidBodySim controller signature.\n\nA DiffEqCallbacks.PeriodicCallback can be created from a PeriodicController, and is used to stop ODE integration exactly every Δt seconds, so that the control! function can be called. Typically, users will not have to explicitly create this PeriodicCallback, as it is automatically created and added to the ODEProblem when the PeriodicController is passed into the RigidBodySim-provided DiffEqBase.ODEProblem constructor overload.\n\nExamples\n\nIn the following example, a PeriodicController is used to simulate a digital PD controller running at a fixed rate of 200 Hz.\n\njulia> using RigidBodySim, RigidBodyDynamics, OrdinaryDiffEq\n\njulia> mechanism = parse_urdf(Float64, joinpath(dirname(pathof(RigidBodySim)), \"..\", \"test\", \"urdf\", \"Acrobot.urdf\"));\n\njulia> state = MechanismState(mechanism);\n\njulia> set_configuration!(state, [0.1; 0.2]);\n\njulia> controlcalls = Ref(0);\n\njulia> pdcontrol!(τ, t, state) = (controlcalls[] += 1; τ .= -20 .* velocity(state) .- 100 .* configuration(state));\n\njulia> τ = zero(velocity(state)); Δt = 1 / 200\n0.005\n\njulia> problem = ODEProblem(Dynamics(mechanism, PeriodicController(τ, Δt, pdcontrol!)), state, (0., 5.));\n\njulia> sol = solve(problem, Tsit5());\n\njulia> @assert all(x -> isapprox(x, 0, atol = 1e-4), sol.u[end]) # ensure state converges to zero\n\njulia> controlcalls[]\n1001\n\n\n\n\n\n","category":"type"},{"location":"details/#RigidBodySim.Control.SumController","page":"Details","title":"RigidBodySim.Control.SumController","text":"struct SumController{Tau<:(AbstractArray{T,1} where T), C<:Tuple}\n\nA SumController can be used to combine multiple controllers, summing the control torques that each of these controllers produces.\n\nExamples\n\njulia> using RigidBodySim, RigidBodyDynamics\n\njulia> mechanism = parse_urdf(Float64, joinpath(dirname(pathof(RigidBodySim)), \"..\", \"test\", \"urdf\", \"Acrobot.urdf\"));\n\njulia> state = MechanismState(mechanism);\n\njulia> c1 = (τ, t, state) -> τ .= t;\n\njulia> c2 = (τ, t, state) -> τ .= 2 * t;\n\njulia> sumcontroller = SumController(similar(velocity(state)), (c1, c2))\n\njulia> τ = similar(velocity(state))\n\njulia> controller(τ, 1.0, state);\n\njulia> @assert all(τ .== 3.0);\n\n\n\n\n\n","category":"type"},{"location":"details/#Visualization-1","page":"Details","title":"Visualization","text":"","category":"section"},{"location":"details/#","page":"Details","title":"Details","text":"RigidBodySim uses MeshCatMechanisms.jl for 3D visualization.","category":"page"},{"location":"details/#","page":"Details","title":"Details","text":"GUI\nSimulationControls\nDiffEqBase.CallbackSet(::MeshCatMechanisms.MechanismVisualizer)\nDiffEqBase.CallbackSet(::RigidBodySim.GUI)\nMeshCatMechanisms.setanimation!(::MeshCatMechanisms.MechanismVisualizer, ::DiffEqBase.ODESolution)","category":"page"},{"location":"details/#RigidBodySim.Visualization.GUI","page":"Details","title":"RigidBodySim.Visualization.GUI","text":"GUI(visualizer; usernode)\n\n\nCreate a new RigidBodySim graphical user interface given a visualizer (e.g. a MeshCatMechanisms.MechanismVisualizer).\n\nThe visualizer must support:\n\nBase.copyto!(visualizer, state::Union{MechanismState, AbstractVector})\nBase.wait(visualizer)\nMeshCatMechanisms.visualizer(visualizer), which should return a MeshCat.Visualizer.\n\nUse open(gui) to open the GUI in a standalone window.\n\n\n\n\n\nGUI(mechanism, args; usernode)\n\n\nCreate a new RigidBodySim graphical user interface for the given Mechanism. All arguments are passed on to the MeshCatMechanisms.MechanismVisualizer constructor.\n\nUse open(gui) to open the GUI in a standalone window.\n\n\n\n\n\n","category":"type"},{"location":"details/#RigidBodySim.Visualization.SimulationControls","page":"Details","title":"RigidBodySim.Visualization.SimulationControls","text":"SimulationControls()\n\n\nCreate a new SimulationControls object, which may be used to pause and terminate the simulation.\n\nThe controls can be displayed in a standalone window using open(controls, Blink.Window()).\n\n\n\n\n\n","category":"type"},{"location":"details/#DiffEqBase.CallbackSet-Tuple{MeshCatMechanisms.MechanismVisualizer}","page":"Details","title":"DiffEqBase.CallbackSet","text":"CallbackSet(vis; max_fps)\n\n\nCreate the DifferentialEquations.jl callbacks needed for publishing to a visualizer during simulation.\n\nmax_fps is the maximum number of frames per second (in terms of wall time) to draw. Default: 60.0.\n\n\n\n\n\n","category":"method"},{"location":"details/#DiffEqBase.CallbackSet-Tuple{GUI}","page":"Details","title":"DiffEqBase.CallbackSet","text":"CallbackSet(gui; max_fps)\n\n\nCreate the DifferentialEquations.jl callbacks associated with the GUI.\n\nmax_fps is the maximum number of frames per second (in terms of wall time) to draw. Default: 60.0.\n\n\n\n\n\n","category":"method"},{"location":"details/#MeshCat.setanimation!-Tuple{MeshCatMechanisms.MechanismVisualizer,DiffEqBase.ODESolution}","page":"Details","title":"MeshCat.setanimation!","text":"setanimation!(mvis, sol; max_fps, realtime_rate, pause_pollint)\n\n\nPlay back a visualization of a RigidBodySim.jl simulation.\n\nPositional arguments:\n\nvis is a MeshCatMechanisms.MechanismVisualizer\nsol is a DiffEqBase.ODESolution obtained from a RigidBodySim.jl simulation.\n\nsetanimation accepts the following keyword arguments:\n\nmax_fps: the maximum number of frames per second to draw. Default: 60.\nrealtime_rate: can be used to slow down or speed up playback compared to wall time. A realtime_rate of 2 will result in playback that is sped up 2x. Default: 1.0.\n\nExamples\n\nVisualizing the result of a simulation of the passive dynamics of an Acrobot (double pendulum) at half speed:\n\nusing RigidBodySim, RigidBodyDynamics, MeshCatMechanisms, Blink\nurdf = joinpath(dirname(pathof(RigidBodySim)), \"..\", \"test\", \"urdf\", \"Acrobot.urdf\")\nmechanism = parse_urdf(Float64, urdf)\nstate = MechanismState(mechanism)\nset_configuration!(state, [0.1; 0.2])\nproblem = ODEProblem(Dynamics(mechanism), state, (0., 2.))\nsol = solve(problem, Vern7())\nvis = MechanismVisualizer(mechanism, URDFVisuals(urdf))\n# open(vis, Window()) # uncomment to open the visualizer window\nsetanimation!(vis, sol; realtime_rate = 0.5);\n\n\n\n\n\n","category":"method"},{"location":"details/#Utilities-1","page":"Details","title":"Utilities","text":"","category":"section"},{"location":"details/#","page":"Details","title":"Details","text":"configuration_renormalizer\nRealtimeRateLimiter(; kwargs...)","category":"page"},{"location":"details/#RigidBodySim.Core.configuration_renormalizer","page":"Details","title":"RigidBodySim.Core.configuration_renormalizer","text":"configuration_renormalizer(state)\nconfiguration_renormalizer(state, condition)\n\n\nconfiguration_renormalizer can be used to create a callback that projects the configuration of a mechanism's state onto the configuration manifold. This may be necessary for mechanism's with e.g. quaternion-parameterized orientations as part of their joint configuration vectors, as numerical integration can cause the configuration to drift away from the unit norm constraints.\n\nThe callback is implemented as a DiffEqCallbacks.DiscreteCallback By default, it is called at every integrator time step.\n\n\n\n\n\n","category":"function"},{"location":"details/#RigidBodySim.Core.RealtimeRateLimiter-Tuple{}","page":"Details","title":"RigidBodySim.Core.RealtimeRateLimiter","text":"RealtimeRateLimiter(; max_rate, poll_interval, save_positions, reset_interval)\n\n\nRealtimeRateLimiter(; max_rate = 1., poll_interval = 1 / 30; save_positions = (false, false))\n\nA DiscreteCallback that limits the rate of integration so that integration time t increases at a rate no higher than max_rate compared to wall time.\n\nA RealtimeRateLimiter can be used, for example, if you want to simulate a physical system including its timing characteristics. Specific use cases may include realtime animation and user interaction during the simulation.\n\nThe poll_interval keyword argument can be used to control how often the integration is stopped to check whether to sleep (and for how long). Specifically, this operation happens every poll_interval / max_rate in terms of integration time, which corresponds to approximately every poll_interval seconds wall time if max_rate is actually achieved.\n\n\n\n\n\n","category":"method"}]
}
