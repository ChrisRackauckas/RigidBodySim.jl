<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Details · RigidBodySim.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>RigidBodySim.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../quickstart/">Quick start guide</a></li><li class="current"><a class="toctext" href>Details</a><ul class="internal"><li><a class="toctext" href="#ODE-problem-creation-1">ODE problem creation</a></li><li><a class="toctext" href="#control-1">Control</a></li><li><a class="toctext" href="#Visualization-1">Visualization</a></li><li><a class="toctext" href="#Utilities-1">Utilities</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Details</a></li></ul><a class="edit-page" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/master/docs/src/details.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Details</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Details-1" href="#Details-1">Details</a></h1><h2><a class="nav-anchor" id="ODE-problem-creation-1" href="#ODE-problem-creation-1">ODE problem creation</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodySim.Core.Dynamics" href="#RigidBodySim.Core.Dynamics"><code>RigidBodySim.Core.Dynamics</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Dynamics(mechanism)
Dynamics(mechanism, control!; setparams!)
</code></pre><p>Create a <code>Dynamics</code> object, representing either the passive or closed-loop dynamics of a <code>RigidBodyDynamics.Mechanism</code>.</p><p>The <code>control!</code> argument is a callable with the signature <code>control!(τ, t, state)</code>, where <code>τ</code> is the torque vector to be set in the body of <code>control!</code>, <code>t</code> is the current time, and <code>state</code> is a <code>MechanismState</code> object. By default, <code>control!</code> is <a href="#RigidBodySim.Core.zero_control!"><code>zero_control!</code></a> (resulting in the passive dynamics).</p><p>The <code>setparams!</code> keyword argument is a callable with the signature <code>setparams!(state, p)</code> where <code>state</code> is a <code>MechanismState</code> and <code>p</code> is a vector of parameters, as used in OrdinaryDiffEq.jl.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/6dd7ef055a7f1c8e7460611a75b0b6085fc2ac28/src/core.jl#L57-L66">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.ODEProblem-Tuple{Dynamics,Union{AbstractArray{T,1} where T, MechanismState},Any}" href="#DiffEqBase.ODEProblem-Tuple{Dynamics,Union{AbstractArray{T,1} where T, MechanismState},Any}"><code>DiffEqBase.ODEProblem</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ODEProblem(dynamics, x0, tspan)
ODEProblem(dynamics, x0, tspan, p; callback, kwargs...)
</code></pre><p>Create a <code>DiffEqBase.ODEProblem</code> associated with the dynamics of a <code>RigidBodyDynamics.Mechanism</code>.</p><p>The initial state <code>x0</code> can be either a <a href="http://JuliaRobotics.github.io/RigidBodyDynamics.jl/stable/mechanismstate.html#RigidBodyDynamics.MechanismState"><code>RigidBodyDynamics.MechanismState</code></a>), or an <code>AbstractVector</code> containing the initial state represented as <code>[q; v; s]</code>, where <code>q</code> is the configuration vector, <code>v</code> is the velocity vector, and <code>s</code> is the vector of additional states.</p><p>The <code>callback</code> keyword argument can be used to pass in additional <a href="http://docs.juliadiffeq.org/stable/features/callback_functions.html#Using-Callbacks-1">DifferentialEquations.jl callbacks</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/6dd7ef055a7f1c8e7460611a75b0b6085fc2ac28/src/core.jl#L103-L113">source</a></section><h2><a class="nav-anchor" id="control-1" href="#control-1">Control</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodySim.Core.zero_control!" href="#RigidBodySim.Core.zero_control!"><code>RigidBodySim.Core.zero_control!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">zero_control!(τ, t, state)
</code></pre><p>A &#39;zero&#39; controller, i.e. one that sets all control torques to zero at all times.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/6dd7ef055a7f1c8e7460611a75b0b6085fc2ac28/src/core.jl#L44-L46">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodySim.Core.controlcallback" href="#RigidBodySim.Core.controlcallback"><code>RigidBodySim.Core.controlcallback</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">controlcallback(control!)
</code></pre><p>Can be used to create a callback associated with a given controller.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/6dd7ef055a7f1c8e7460611a75b0b6085fc2ac28/src/core.jl#L98-L100">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodySim.Control.PeriodicController" href="#RigidBodySim.Control.PeriodicController"><code>RigidBodySim.Control.PeriodicController</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct PeriodicController{Tau&lt;:(AbstractArray{T,1} where T), T&lt;:Number, C, I}</code></pre><p>A <code>PeriodicController</code> can be used to simulate a digital controller that runs at a fixed rate (in terms of simulation time). It does so by performing a zero-order hold on a provided control function.</p><p><code>PeriodicController</code>s can be constructed using</p><pre><code class="language-julia">PeriodicController(τ, Δt, control!; initialize = DiffEqBase.INITIALIZE_DEFAULT, save_positions = (false, false))</code></pre><p>where <code>control!</code> is a controller satisfying the standard RigidBodySim controller signature (<code>control!(τ, Δt, state)</code>), <code>Δt</code> is the simulation time interval between calls to the <code>control!</code> function, and <code>τ</code> is used to call <code>control!</code>. The <code>initialize</code> and <code>save_positions</code> keyword arguments are documented in the <a href="http://docs.juliadiffeq.org/release-4.0/features/callback_functions.html#DiscreteCallback-1"><code>DiscreteCallback</code></a> section of the DifferentialEquations documentation.</p><p><code>PeriodicController</code>s are callable objects, and themselves fit the standard RigidBodySim controller signature.</p><p>A <code>DiffEqCallbacks.PeriodicCallback</code> can be created from a <code>PeriodicController</code>, and is used to stop ODE integration exactly every <code>Δt</code> seconds, so that the <code>control!</code> function can be called. Typically, users will not have to explicitly create this <code>PeriodicCallback</code>, as it is automatically created and added to the <code>ODEProblem</code> when the <code>PeriodicController</code> is passed into the RigidBodySim-provided <code>DiffEqBase.ODEProblem</code> constructor overload.</p><p><strong>Examples</strong></p><p>In the following example, a <code>PeriodicController</code> is used to simulate a digital PD controller running at a fixed rate of 200 Hz.</p><pre><code class="language-julia-repl">julia&gt; using RigidBodySim, RigidBodyDynamics, OrdinaryDiffEq

julia&gt; mechanism = parse_urdf(Float64, joinpath(dirname(pathof(RigidBodySim)), &quot;..&quot;, &quot;test&quot;, &quot;urdf&quot;, &quot;Acrobot.urdf&quot;));

julia&gt; state = MechanismState(mechanism);

julia&gt; set_configuration!(state, [0.1; 0.2]);

julia&gt; controlcalls = Ref(0);

julia&gt; pdcontrol!(τ, t, state) = (controlcalls[] += 1; τ .= -20 .* velocity(state) .- 100 .* configuration(state));

julia&gt; τ = zero(velocity(state)); Δt = 1 / 200
0.005

julia&gt; problem = ODEProblem(Dynamics(mechanism, PeriodicController(τ, Δt, pdcontrol!)), state, (0., 5.));

julia&gt; sol = solve(problem, Tsit5());

julia&gt; @assert all(x -&gt; isapprox(x, 0, atol = 1e-4), sol.u[end]) # ensure state converges to zero

julia&gt; controlcalls[]
1001</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/6dd7ef055a7f1c8e7460611a75b0b6085fc2ac28/src/control.jl#L29-L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodySim.Control.SumController" href="#RigidBodySim.Control.SumController"><code>RigidBodySim.Control.SumController</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct SumController{Tau&lt;:(AbstractArray{T,1} where T), C&lt;:Tuple}</code></pre><p>A <code>SumController</code> can be used to combine multiple controllers, summing the control torques that each of these controllers produces.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using RigidBodySim, RigidBodyDynamics

julia&gt; mechanism = parse_urdf(Float64, joinpath(dirname(pathof(RigidBodySim)), &quot;..&quot;, &quot;test&quot;, &quot;urdf&quot;, &quot;Acrobot.urdf&quot;));

julia&gt; state = MechanismState(mechanism);

julia&gt; c1 = (τ, t, state) -&gt; τ .= t;

julia&gt; c2 = (τ, t, state) -&gt; τ .= 2 * t;

julia&gt; sumcontroller = SumController(similar(velocity(state)), (c1, c2))

julia&gt; τ = similar(velocity(state))

julia&gt; controller(τ, 1.0, state);

julia&gt; @assert all(τ .== 3.0);</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/6dd7ef055a7f1c8e7460611a75b0b6085fc2ac28/src/control.jl#L154-L179">source</a></section><h2><a class="nav-anchor" id="Visualization-1" href="#Visualization-1">Visualization</a></h2><p>RigidBodySim uses <a href="https://github.com/JuliaRobotics/MeshCatMechanisms.jl">MeshCatMechanisms.jl</a> for 3D visualization.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodySim.Visualization.GUI" href="#RigidBodySim.Visualization.GUI"><code>RigidBodySim.Visualization.GUI</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">GUI(visualizer; usernode)
</code></pre><p>Create a new RigidBodySim graphical user interface given a visualizer (e.g. a <code>MeshCatMechanisms.MechanismVisualizer</code>).</p><p>The visualizer must support:</p><ul><li><code>Base.copyto!(visualizer, state::Union{MechanismState, AbstractVector})</code></li><li><code>Base.wait(visualizer)</code></li><li><code>MeshCatMechanisms.visualizer(visualizer)</code>, which should return a <code>MeshCat.Visualizer</code>.</li></ul><p>Use <code>open(gui)</code> to open the GUI in a standalone window.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/6dd7ef055a7f1c8e7460611a75b0b6085fc2ac28/src/visualization.jl#L179-L189">source</a><div><div><pre><code class="language-julia">GUI(mechanism, args; usernode)
</code></pre><p>Create a new RigidBodySim graphical user interface for the given Mechanism. All arguments are passed on to the <code>MeshCatMechanisms.MechanismVisualizer</code> constructor.</p><p>Use <code>open(gui)</code> to open the GUI in a standalone window.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/6dd7ef055a7f1c8e7460611a75b0b6085fc2ac28/src/visualization.jl#L192-L197">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodySim.Visualization.SimulationControls" href="#RigidBodySim.Visualization.SimulationControls"><code>RigidBodySim.Visualization.SimulationControls</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SimulationControls()
</code></pre><p>Create a new <code>SimulationControls</code> object, which may be used to pause and terminate the simulation.</p><p>The controls can be displayed in a standalone window using <code>open(controls, Blink.Window())</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/6dd7ef055a7f1c8e7460611a75b0b6085fc2ac28/src/visualization.jl#L103-L107">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.CallbackSet-Tuple{MeshCatMechanisms.MechanismVisualizer}" href="#DiffEqBase.CallbackSet-Tuple{MeshCatMechanisms.MechanismVisualizer}"><code>DiffEqBase.CallbackSet</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">CallbackSet(vis; max_fps)
</code></pre><p>Create the DifferentialEquations.jl callbacks needed for publishing to a visualizer during simulation.</p><p><code>max_fps</code> is the maximum number of frames per second (in terms of wall time) to draw. Default: <code>60.0</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/6dd7ef055a7f1c8e7460611a75b0b6085fc2ac28/src/visualization.jl#L224-L229">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.CallbackSet-Tuple{GUI}" href="#DiffEqBase.CallbackSet-Tuple{GUI}"><code>DiffEqBase.CallbackSet</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">CallbackSet(gui; max_fps)
</code></pre><p>Create the DifferentialEquations.jl callbacks associated with the <a href="#RigidBodySim.Visualization.GUI"><code>GUI</code></a>.</p><p><code>max_fps</code> is the maximum number of frames per second (in terms of wall time) to draw. Default: <code>60.0</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/6dd7ef055a7f1c8e7460611a75b0b6085fc2ac28/src/visualization.jl#L215-L219">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MeshCat.setanimation!-Tuple{MeshCatMechanisms.MechanismVisualizer,DiffEqBase.ODESolution}" href="#MeshCat.setanimation!-Tuple{MeshCatMechanisms.MechanismVisualizer,DiffEqBase.ODESolution}"><code>MeshCat.setanimation!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">setanimation!(vis, sol; max_fps, realtime_rate, pause_pollint)
</code></pre><p>Play back a visualization of a RigidBodySim.jl simulation.</p><p>Positional arguments:</p><ul><li><code>vis</code> is a <code>MeshCatMechanisms.MechanismVisualizer</code></li><li><code>sol</code> is a <code>DiffEqBase.ODESolution</code> obtained from a RigidBodySim.jl simulation.</li></ul><p><code>setanimation</code> accepts the following keyword arguments:</p><ul><li><code>max_fps</code>: the maximum number of frames per second to draw. Default: <code>60.0</code>.</li><li><code>realtime_rate</code>: can be used to slow down or speed up playback compared to wall time. A <code>realtime_rate</code> of <code>2</code> will result in playback that is sped up 2x. Default: <code>1.0</code>.</li></ul><p><strong>Examples</strong></p><p>Visualizing the result of a simulation of the passive dynamics of an Acrobot (double pendulum) at half speed:</p><pre><code class="language-julia">using RigidBodySim, RigidBodyDynamics, MeshCatMechanisms, Blink
urdf = joinpath(dirname(pathof(RigidBodySim)), &quot;..&quot;, &quot;test&quot;, &quot;urdf&quot;, &quot;Acrobot.urdf&quot;)
mechanism = parse_urdf(Float64, urdf)
state = MechanismState(mechanism)
set_configuration!(state, [0.1; 0.2])
problem = ODEProblem(Dynamics(mechanism), state, (0., 2.))
sol = solve(problem, Vern7())
vis = MechanismVisualizer(mechanism, URDFVisuals(urdf))
# open(vis, Window()) # uncomment to open the visualizer window
setanimation!(vis, sol; realtime_rate = 0.5);</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/6dd7ef055a7f1c8e7460611a75b0b6085fc2ac28/src/visualization.jl#L232-L265">source</a></section><h2><a class="nav-anchor" id="Utilities-1" href="#Utilities-1">Utilities</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodySim.Core.configuration_renormalizer" href="#RigidBodySim.Core.configuration_renormalizer"><code>RigidBodySim.Core.configuration_renormalizer</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">configuration_renormalizer(state)
configuration_renormalizer(state, condition)
</code></pre><p><code>configuration_renormalizer</code> can be used to create a callback that projects the configuration of a mechanism&#39;s state onto the configuration manifold. This may be necessary for mechanism&#39;s with e.g. quaternion-parameterized orientations as part of their joint configuration vectors, as numerical integration can cause the configuration to drift away from the unit norm constraints.</p><p>The callback is implemented as a <a href="http://docs.juliadiffeq.org/stable/features/callback_functions.html#DiscreteCallback-1"><code>DiffEqCallbacks.DiscreteCallback</code></a> By default, it is called at every integrator time step.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/6dd7ef055a7f1c8e7460611a75b0b6085fc2ac28/src/core.jl#L124-L133">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodySim.Core.RealtimeRateLimiter-Tuple{}" href="#RigidBodySim.Core.RealtimeRateLimiter-Tuple{}"><code>RigidBodySim.Core.RealtimeRateLimiter</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">RealtimeRateLimiter(; max_rate, poll_interval, save_positions, reset_interval)
</code></pre><pre><code class="language-none">RealtimeRateLimiter(; max_rate = 1., poll_interval = 1 / 30; save_positions = (false, false))</code></pre><p>A <code>DiscreteCallback</code> that limits the rate of integration so that integration time <code>t</code> increases at a rate no higher than <code>max_rate</code> compared to wall time.</p><p>A <code>RealtimeRateLimiter</code> can be used, for example, if you want to simulate a physical system including its timing characteristics. Specific use cases may include realtime animation and user interaction during the simulation.</p><p>The <code>poll_interval</code> keyword argument can be used to control how often the integration is stopped to check whether to sleep (and for how long). Specifically, this operation happens every <code>poll_interval / max_rate</code> <em>in terms of integration time</em>, which corresponds to approximately every <code>poll_interval</code> seconds <em>wall time</em> if <code>max_rate</code> is actually achieved.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/6dd7ef055a7f1c8e7460611a75b0b6085fc2ac28/src/core.jl#L155-L169">source</a></section><footer><hr/><a class="previous" href="../quickstart/"><span class="direction">Previous</span><span class="title">Quick start guide</span></a></footer></article></body></html>
