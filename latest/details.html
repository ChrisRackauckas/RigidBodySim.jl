<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Details · RigidBodySim.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>RigidBodySim.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="quickstart.html">Quick start guide</a></li><li class="current"><a class="toctext" href="details.html">Details</a><ul class="internal"><li><a class="toctext" href="#Index-1">Index</a></li><li><a class="toctext" href="#ODE-problem-creation-1">ODE problem creation</a></li><li><a class="toctext" href="#control-1">Control</a></li><li><a class="toctext" href="#Visualization-1">Visualization</a></li><li><a class="toctext" href="#Utilities-1">Utilities</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="details.html">Details</a></li></ul><a class="edit-page" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/master/docs/src/details.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Details</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Details-1" href="#Details-1">Details</a></h1><h2><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h2><h2><a class="nav-anchor" id="ODE-problem-creation-1" href="#ODE-problem-creation-1">ODE problem creation</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodySim.Core.Dynamics" href="#RigidBodySim.Core.Dynamics"><code>RigidBodySim.Core.Dynamics</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">Dynamics(mechanism)
Dynamics(mechanism, control!; setparams!)
</code></pre><p>Create a <code>Dynamics</code> object, representing either the passive or closed-loop dynamics of a <code>RigidBodyDynamics.Mechanism</code>.</p><p>The <code>control!</code> argument is a callable with the signature <code>control!(τ, t, state)</code>, where <code>τ</code> is the torque vector to be set in the body of <code>control!</code>, <code>t</code> is the current time, and <code>state</code> is a <code>MechanismState</code> object. By default, <code>control!</code> is <a href="details.html#RigidBodySim.Core.zero_control!"><code>zero_control!</code></a> (resulting in the passive dynamics).</p><p>The <code>setparams!</code> keyword argument is a callable with the signature <code>setparams!(state, p)</code> where <code>state</code> is a <code>MechanismState</code> and <code>p</code> is a vector of parameters, as used in OrdinaryDiffEq.jl.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/dc77c26d664219d7ed0321c70f4e21900f4a6d7b/src/core.jl#L53-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.ODEProblem-Tuple{RigidBodySim.Core.Dynamics,Union{AbstractArray{T,1} where T, RigidBodyDynamics.MechanismState},Any}" href="#DiffEqBase.ODEProblem-Tuple{RigidBodySim.Core.Dynamics,Union{AbstractArray{T,1} where T, RigidBodyDynamics.MechanismState},Any}"><code>DiffEqBase.ODEProblem</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">ODEProblem(dynamics, x0, tspan)
ODEProblem(dynamics, x0, tspan, p; callback, kwargs...)
</code></pre><p>Create a <code>DiffEqBase.ODEProblem</code> associated with the dynamics of a <code>RigidBodyDynamics.Mechanism</code>.</p><p>The initial state <code>x0</code> can be either a <a href="http://JuliaRobotics.github.io/RigidBodyDynamics.jl/stable/mechanismstate.html#RigidBodyDynamics.MechanismState"><code>RigidBodyDynamics.MechanismState</code></a>), or an <code>AbstractVector</code> containing the initial state represented as <code>[q; v; s]</code>, where <code>q</code> is the configuration vector, <code>v</code> is the velocity vector, and <code>s</code> is the vector of additional states.</p><p>The <code>callback</code> keyword argument can be used to pass in additional <a href="http://docs.juliadiffeq.org/stable/features/callback_functions.html#Using-Callbacks-1">DifferentialEquations.jl callbacks</a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/dc77c26d664219d7ed0321c70f4e21900f4a6d7b/src/core.jl#L99-L109">source</a></section><h2><a class="nav-anchor" id="control-1" href="#control-1">Control</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodySim.Core.zero_control!" href="#RigidBodySim.Core.zero_control!"><code>RigidBodySim.Core.zero_control!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">zero_control!(τ, t, state)
</code></pre><p>A &#39;zero&#39; controller, i.e. one that sets all control torques to zero at all times.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/dc77c26d664219d7ed0321c70f4e21900f4a6d7b/src/core.jl#L40-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodySim.Core.controlcallback" href="#RigidBodySim.Core.controlcallback"><code>RigidBodySim.Core.controlcallback</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">controlcallback(control!)
</code></pre><p>Can be used to create a callback associated with a given controller.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/dc77c26d664219d7ed0321c70f4e21900f4a6d7b/src/core.jl#L94-L96">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodySim.Control.PeriodicController" href="#RigidBodySim.Control.PeriodicController"><code>RigidBodySim.Control.PeriodicController</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">struct PeriodicController{Tau&lt;:(AbstractArray{T,1} where T), T&lt;:Number, C, I}</code></pre><p>A <code>PeriodicController</code> can be used to simulate a digital controller that runs at a fixed rate (in terms of simulation time). It does so by performing a zero-order hold on a provided control function.</p><p><code>PeriodicController</code>s can be constructed using</p><pre><code class="language-julia">PeriodicController(τ, Δt, control!; initialize = DiffEqBase.INITIALIZE_DEFAULT, save_positions = (false, false))</code></pre><p>where <code>control!</code> is a controller satisfying the standard RigidBodySim controller signature (<code>control!(τ, Δt, state)</code>), <code>Δt</code> is the simulation time interval between calls to the <code>control!</code> function, and <code>τ</code> is used to call <code>control!</code>. The <code>initialize</code> and <code>save_positions</code> keyword arguments are documented in the <a href="http://docs.juliadiffeq.org/release-4.0/features/callback_functions.html#DiscreteCallback-1"><code>DiscreteCallback</code></a> section of the DifferentialEquations documentation.</p><p><code>PeriodicController</code>s are callable objects, and themselves fit the standard RigidBodySim controller signature.</p><p>A <code>DiffEqCallbacks.PeriodicCallback</code> can be created from a <code>PeriodicController</code>, and is used to stop ODE integration exactly every <code>Δt</code> seconds, so that the <code>control!</code> function can be called. Typically, users will not have to explicitly create this <code>PeriodicCallback</code>, as it is automatically created and added to the <code>ODEProblem</code> when the <code>PeriodicController</code> is passed into the RigidBodySim-provided <code>DiffEqBase.ODEProblem</code> constructor overload.</p><p><strong>Examples</strong></p><p>In the following example, a <code>PeriodicController</code> is used to simulate a digital PD controller running at a fixed rate of 200 Hz.</p><pre><code class="language-julia-repl">julia&gt; using RigidBodySim, RigidBodyDynamics, OrdinaryDiffEq

julia&gt; mechanism = parse_urdf(Float64, Pkg.dir(&quot;RigidBodySim&quot;, &quot;test&quot;, &quot;urdf&quot;, &quot;Acrobot.urdf&quot;));

julia&gt; state = MechanismState(mechanism);

julia&gt; set_configuration!(state, [0.1; 0.2]);

julia&gt; controlcalls = Ref(0);

julia&gt; pdcontrol!(τ, t, state) = (controlcalls[] += 1; τ .= -20 .* velocity(state) .- 100 .* configuration(state));

julia&gt; τ = zeros(velocity(state)); Δt = 1 / 200
0.005

julia&gt; problem = ODEProblem(Dynamics(mechanism, PeriodicController(τ, Δt, pdcontrol!)), state, (0., 5.));

julia&gt; sol = solve(problem, Tsit5());

julia&gt; sol.u[end]
4-element Array{Float64,1}:
 -3.25923e-5
 -1.67942e-5
  8.16715e-7
  1.55292e-8

julia&gt; @assert all(x -&gt; isapprox(x, 0, atol = 1e-4), sol.u[end]) # ensure state converges to zero

julia&gt; controlcalls[]
1001</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/dc77c26d664219d7ed0321c70f4e21900f4a6d7b/src/control.jl#L25-L90">source</a></section><h2><a class="nav-anchor" id="Visualization-1" href="#Visualization-1">Visualization</a></h2><h3><a class="nav-anchor" id="User-interface-1" href="#User-interface-1">User interface</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.CallbackSet-Tuple{DrakeVisualizer.Visualizer,RigidBodyDynamics.MechanismState}" href="#DiffEqBase.CallbackSet-Tuple{DrakeVisualizer.Visualizer,RigidBodyDynamics.MechanismState}"><code>DiffEqBase.CallbackSet</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">CallbackSet(vis, state; max_fps)
</code></pre><p>Create the DifferentialEquations.jl callbacks needed for publishing to and receiving commands from a visualizer during simulation.</p><p><code>max_fps</code> is the maximum number of frames per second (in terms of wall time) to draw. Default: <code>60.0</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/dc77c26d664219d7ed0321c70f4e21900f4a6d7b/src/visualization.jl#L124-L129">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodySim.Visualization.VisualizerInterface.visualize" href="#RigidBodySim.Visualization.VisualizerInterface.visualize"><code>RigidBodySim.Visualization.VisualizerInterface.visualize</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">visualize(vis, t::Number, state::MechanismState)</code></pre><p>Visualize a <code>Mechanism</code> at the given time and in the given state using visualizer <code>vis</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/dc77c26d664219d7ed0321c70f4e21900f4a6d7b/src/visualization.jl#L42-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodySim.Visualization.VisualizerInterface.window" href="#RigidBodySim.Visualization.VisualizerInterface.window"><code>RigidBodySim.Visualization.VisualizerInterface.window</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">window(vis; kwargs...)</code></pre><p>Create a new window for visualizer <code>vis</code>. Visualizer-specific keyword arguments (<code>kwargs</code>) may be passed in.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/dc77c26d664219d7ed0321c70f4e21900f4a6d7b/src/visualization.jl#L50-L55">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodySim.Visualization.animate" href="#RigidBodySim.Visualization.animate"><code>RigidBodySim.Visualization.animate</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">animate(vis, state, sol; max_fps, realtime_rate, pause_pollint)
</code></pre><p>Play back a visualization of a RigidBodySim.jl simulation.</p><p>Positional arguments:</p><ul><li><p><code>vis</code> is a visualizer satisfying the RigidBodySim <a href="details.html#vis_interface-1">visualizer interface</a>.</p></li><li><p><code>state</code> is a <a href="http://JuliaRobotics.github.io/RigidBodyDynamics.jl/release-0.4/mechanismstate.html#RigidBodyDynamics.MechanismState"><code>RigidBodyDynamics.MechanismState</code></a>,</p></li></ul><p>representing the state of the mechanism that was simulated, and will be modified during the visualization.</p><ul><li><p><code>sol</code> is a <code>DiffEqBase.ODESolution</code> obtained from a RigidBodySim.jl simulation.</p></li></ul><p><code>animate</code> accepts the following keyword arguments:</p><ul><li><p><code>max_fps</code>: the maximum number of frames per second to draw. Default: <code>60.0</code>.</p></li><li><p><code>realtime_rate</code>: can be used to slow down or speed up playback compared to wall time. A <code>realtime_rate</code> of <code>2</code> will result in playback that is sped up 2x. Default: <code>1.0</code>.</p></li><li><p><code>pause_pollint</code>: how often to poll for commands coming from the director window when playback is paused. Default: 0.05.</p></li></ul><p><strong>Examples</strong></p><p>Visualizing the result of a simulation of the passive dynamics of an Acrobot (double pendulum) at half speed:</p><pre><code class="language-julia">using RigidBodySim, RigidBodyDynamics, MechanismGeometries
import RigidBodyTreeInspector: Visualizer
urdf = Pkg.dir(&quot;RigidBodySim&quot;, &quot;test&quot;, &quot;urdf&quot;, &quot;Acrobot.urdf&quot;)
mechanism = parse_urdf(Float64, urdf)
state = MechanismState(mechanism)
set_configuration!(state, [0.1; 0.2])
problem = ODEProblem(Dynamics(mechanism), state, (0., 2.))
sol = solve(problem, Vern7())
vis = Visualizer(mechanism, visual_elements(mechanism, URDFVisuals(urdf)))
window(vis)
animate(vis, state, sol; realtime_rate = 0.5)

# output
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/dc77c26d664219d7ed0321c70f4e21900f4a6d7b/src/visualization.jl#L135-L172">source</a></section><h3><a class="nav-anchor" id="Visualizers-1" href="#Visualizers-1">Visualizers</a></h3><h4><a class="nav-anchor" id="RigidBodyTreeInspector-1" href="#RigidBodyTreeInspector-1">RigidBodyTreeInspector</a></h4><p>RigidBodySim provides an interface for the <a href="https://github.com/rdeits/RigidBodyTreeInspector.jl">RigidBodyTreeInspector.jl</a> visualizer, built on top of <a href="https://github.com/RobotLocomotion/director">Director</a>.</p><p>The RigidBodyTreeInspector visualizer handle is a <code>DrakeVisualizer.Visualizer</code>. The easiest way to create a <code>Visualizer</code> for a robot is from a URDF, which can be parsed by RigidBodyTreeInspector&#39;s <code>parse_urdf</code> function.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodySim.Visualization.VisualizerInterface.window-Tuple{DrakeVisualizer.Visualizer}" href="#RigidBodySim.Visualization.VisualizerInterface.window-Tuple{DrakeVisualizer.Visualizer}"><code>RigidBodySim.Visualization.VisualizerInterface.window</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">window(vis; reuse)
</code></pre><p>Open a new <a href="https://github.com/RobotLocomotion/director">director</a> visualizer window.</p><p>The director instance will be started with a script that handles communication between RigidBodySim.jl and the director instance.</p><p>Supports the following keyword arguments:</p><ul><li><p><code>reuse</code>: skip opening a new visualizer window if one is already open.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/dc77c26d664219d7ed0321c70f4e21900f4a6d7b/src/visualizers/rigid_body_tree_inspector.jl#L47">source</a></section><h4><a class="nav-anchor" id="MeshCatMechanisms-1" href="#MeshCatMechanisms-1">MeshCatMechanisms</a></h4><p>RigidBodySim has support for the <a href="https://github.com/JuliaRobotics/MeshCatMechanisms.jl">MeshCatMechanisms.jl</a> <code>MechanismVisualizer</code>. Support is currently non-interactive, i.e., the simulation cannot be paused or terminated through the visualizer.</p><h3><a class="nav-anchor" id="vis_interface-1" href="#vis_interface-1">Visualizer interface</a></h3><p>RigidBodySim visualizers must implement the following interface:</p><ul><li><p><a href="details.html#RigidBodySim.Visualization.VisualizerInterface.visualize"><code>RigidBodySim.Visualization.VisualizerInterface.visualize</code></a></p></li><li><p><a href="details.html#RigidBodySim.Visualization.VisualizerInterface.window"><code>RigidBodySim.Visualization.VisualizerInterface.window</code></a></p></li></ul><p>In addition, visualizers should also implement the following:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodySim.Visualization.VisualizerInterface.SimulationCommands" href="#RigidBodySim.Visualization.VisualizerInterface.SimulationCommands"><code>RigidBodySim.Visualization.VisualizerInterface.SimulationCommands</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">type SimulationCommands</code></pre><p>Stores visualizer-independent commands used to control the simulation.</p><p>A module providing a specific visualizer instance, say <code>MyVisualizer</code>, should provide a <code>SimulationCommands</code> constructor method with the signature</p><pre><code class="language-julia">SimulationCommands(vis::MyVisualizer)</code></pre><p>which returns a <code>SimulationCommands</code> object (to be constructed using <code>SimulationCommands()</code> in addition to performing any visualizer-dependent setup.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/dc77c26d664219d7ed0321c70f4e21900f4a6d7b/src/visualization.jl#L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodySim.Visualization.VisualizerInterface.isinteractive" href="#RigidBodySim.Visualization.VisualizerInterface.isinteractive"><code>RigidBodySim.Visualization.VisualizerInterface.isinteractive</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isinteractive(vis)</code></pre><p>Return whether or not visualizer <code>vis</code> supports user interaction (e.g. sending pause and terminate commands).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/dc77c26d664219d7ed0321c70f4e21900f4a6d7b/src/visualization.jl#L58-L63">source</a></section><h2><a class="nav-anchor" id="Utilities-1" href="#Utilities-1">Utilities</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodySim.Core.configuration_renormalizer" href="#RigidBodySim.Core.configuration_renormalizer"><code>RigidBodySim.Core.configuration_renormalizer</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">configuration_renormalizer(state)
configuration_renormalizer(state, condition)
</code></pre><p><code>configuration_renormalizer</code> can be used to create a callback that projects the configuration of a mechanism&#39;s state onto the configuration manifold. This may be necessary for mechanism&#39;s with e.g. quaternion-parameterized orientations as part of their joint configuration vectors, as numerical integration can cause the configuration to drift away from the unit norm constraints.</p><p>The callback is implemented as a <a href="http://docs.juliadiffeq.org/stable/features/callback_functions.html#DiscreteCallback-1"><code>DiffEqCallbacks.DiscreteCallback</code></a> By default, it is called at every integrator time step.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/dc77c26d664219d7ed0321c70f4e21900f4a6d7b/src/core.jl#L120-L129">source</a></section><footer><hr/><a class="previous" href="quickstart.html"><span class="direction">Previous</span><span class="title">Quick start guide</span></a></footer></article></body></html>
