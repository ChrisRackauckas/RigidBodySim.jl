<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Details · RigidBodySim.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>RigidBodySim.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="quickstart.html">Quick start guide</a></li><li class="current"><a class="toctext" href="details.html">Details</a><ul class="internal"><li><a class="toctext" href="#Index-1">Index</a></li><li><a class="toctext" href="#ODE-problem-creation-1">ODE problem creation</a></li><li><a class="toctext" href="#control-1">Control</a></li><li><a class="toctext" href="#Visualization-1">Visualization</a></li><li><a class="toctext" href="#Utilities-1">Utilities</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="details.html">Details</a></li></ul><a class="edit-page" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/master/docs/src/details.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Details</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Details-1" href="#Details-1">Details</a></h1><h2><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h2><ul><li><a href="details.html#DiffEqBase.CallbackSet-Tuple{DrakeVisualizer.Visualizer,RigidBodyDynamics.MechanismState}"><code>DiffEqBase.CallbackSet</code></a></li><li><a href="details.html#DiffEqBase.ODEProblem"><code>DiffEqBase.ODEProblem</code></a></li><li><a href="details.html#RigidBodySim.Control.PeriodicController"><code>RigidBodySim.Control.PeriodicController</code></a></li><li><a href="details.html#RigidBodySim.Core.configuration_renormalizer"><code>RigidBodySim.Core.configuration_renormalizer</code></a></li><li><a href="details.html#RigidBodySim.Core.zero_control!"><code>RigidBodySim.Core.zero_control!</code></a></li><li><a href="details.html#RigidBodySim.Visualization.animate-Tuple{DrakeVisualizer.Visualizer,RigidBodyDynamics.MechanismState,DiffEqBase.ODESolution}"><code>RigidBodySim.Visualization.animate</code></a></li><li><a href="details.html#RigidBodySim.Visualization.any_open_visualizer_windows"><code>RigidBodySim.Visualization.any_open_visualizer_windows</code></a></li><li><a href="details.html#RigidBodySim.Visualization.new_visualizer_window"><code>RigidBodySim.Visualization.new_visualizer_window</code></a></li></ul><h2><a class="nav-anchor" id="ODE-problem-creation-1" href="#ODE-problem-creation-1">ODE problem creation</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.ODEProblem" href="#DiffEqBase.ODEProblem"><code>DiffEqBase.ODEProblem</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">ODEProblem(state, tspan)
ODEProblem(state, tspan, control!; callback)
</code></pre><p>Create a <code>DiffEqBase.ODEProblem</code> representing the closed-loop dynamics of a <code>RigidBodyDynamics.Mechanism</code>.</p><p>The initial state is given by the <code>state</code> argument (a <a href="http://JuliaRobotics.github.io/RigidBodyDynamics.jl/release-0.4/mechanismstate.html#RigidBodyDynamics.MechanismState"><code>RigidBodyDynamics.MechanismState</code></a>). The <code>state</code> argument will be modified during the simulation, as it is used to evaluate the dynamics.</p><p>The <code>control!</code> argument is a callable with the signature <code>control!(τ, t, state)</code>, where <code>τ</code> is the torque vector to be set in the body of <code>control!</code>, <code>t</code> is the current time, and <code>state</code> is a <code>MechanismState</code> object. By default, <code>control!</code> is <a href="details.html#RigidBodySim.Core.zero_control!"><code>zero_control!</code></a>.</p><p>The <code>callback</code> keyword argument can be used to pass in additional <a href="http://docs.juliadiffeq.org/release-4.0/features/callback_functions.html#Using-Callbacks-1">DifferentialEquations.jl callbacks</a>.</p><p><strong>Examples</strong></p><p>The following is a ten second simulation of the passive dynamics of an Acrobot (double pendulum) with a <code>Vern7</code> integrator (see <a href="http://docs.juliadiffeq.org/release-4.0/solvers/ode_solve.html#Non-Stiff-Problems-1">DifferentialEquations.jl documentation</a>).</p><pre><code class="language-julia-repl">julia&gt; using RigidBodySim, RigidBodyDynamics, OrdinaryDiffEq

julia&gt; mechanism = parse_urdf(Float64, Pkg.dir(&quot;RigidBodySim&quot;, &quot;test&quot;, &quot;urdf&quot;, &quot;Acrobot.urdf&quot;))
Spanning tree:
Vertex: world (root)
  Vertex: base_link, Edge: base_link_to_world
    Vertex: upper_link, Edge: shoulder
      Vertex: lower_link, Edge: elbow
No non-tree joints.

julia&gt; state = MechanismState(mechanism);

julia&gt; set_configuration!(state, [0.1; 0.2]);

julia&gt; problem = ODEProblem(state, (0., 10.))
DiffEqBase.ODEProblem with uType Array{Float64,1} and tType Float64. In-place: true
timespan: (0.0, 10.0)
u0: [0.1, 0.2, 0.0, 0.0]

julia&gt; solution = solve(problem, Vern7());</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/d0b457b033740a9bc1c29e80c6c33ef1cca84c03/src/core.jl#L38-L79">source</a></section><h2><a class="nav-anchor" id="control-1" href="#control-1">Control</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodySim.Core.zero_control!" href="#RigidBodySim.Core.zero_control!"><code>RigidBodySim.Core.zero_control!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">zero_control!(τ, t, state)
</code></pre><p>A &#39;zero&#39; controller, i.e. one that sets all control torques to zero at all times.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/d0b457b033740a9bc1c29e80c6c33ef1cca84c03/src/core.jl#L33-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodySim.Control.PeriodicController" href="#RigidBodySim.Control.PeriodicController"><code>RigidBodySim.Control.PeriodicController</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">struct PeriodicController{Tau&lt;:(AbstractArray{T,1} where T), T&lt;:Number, C, I}</code></pre><p>A <code>PeriodicController</code> can be used to simulate a digital controller that runs at a fixed rate (in terms of simulation time). It does so by performing a zero-order hold on a provided control function.</p><p><code>PeriodicController</code>s can be constructed using</p><pre><code class="language-julia">PeriodicController(τ, Δt, control; initialize = DiffEqBase.INITIALIZE_DEFAULT, save_positions = (false, false))</code></pre><p>where <code>control</code> is a controller satisfying the standard RigidBodySim controller signature (<code>control(τ, Δt, state)</code>), <code>Δt</code> is the simulation time interval between calls to the <code>control</code> function, and <code>τ</code> is used to call <code>control</code>. The <code>initialize</code> and <code>save_positions</code> keyword arguments are documented in the <a href="http://docs.juliadiffeq.org/release-4.0/features/callback_functions.html#DiscreteCallback-1"><code>DiscreteCallback</code></a> section of the DifferentialEquations documentation.</p><p><code>PeriodicController</code>s are callable objects, and themselves fit the standard RigidBodySim controller signature.</p><p>A <code>DiffEqCallbacks.PeriodicCallback</code> can be created from a <code>PeriodicController</code>, and is used to stop ODE integration exactly every <code>Δt</code> seconds, so that the controller can be called. Typically, users will not have to explicitly create this <code>PeriodicCallback</code>, as it is automatically created and added to the <code>ODEProblem</code> when the <code>PeriodicController</code> is passed into the following <code>DiffEqBase.ODEProblem</code> constructor overload:</p><pre><code class="language-none">ODEProblem(state, tspan, controller::PeriodicController; callback)</code></pre><p><strong>Examples</strong></p><p>In the following example, a <code>PeriodicController</code> is used to simulate a digital PD controller running at a fixed rate of 200 Hz.</p><pre><code class="language-julia-repl">julia&gt; using RigidBodySim, RigidBodyDynamics, OrdinaryDiffEq

julia&gt; mechanism = parse_urdf(Float64, Pkg.dir(&quot;RigidBodySim&quot;, &quot;test&quot;, &quot;urdf&quot;, &quot;Acrobot.urdf&quot;));

julia&gt; state = MechanismState(mechanism);

julia&gt; set_configuration!(state, [0.1; 0.2]);

julia&gt; controlcalls = Ref(0);

julia&gt; pdcontrol!(τ, t, state) = (controlcalls[] += 1; τ .= -20 .* velocity(state) .- 100 .* configuration(state));

julia&gt; τ = zeros(velocity(state)); Δt = 1 / 200
0.005

julia&gt; problem = ODEProblem(state, (0., 5.), PeriodicController(τ, Δt, pdcontrol!));

julia&gt; sol = solve(problem, Tsit5());

julia&gt; sol.u[end]
4-element Array{Float64,1}:
 -3.25923e-5
 -1.67942e-5
  8.16715e-7
  1.55292e-8

julia&gt; @assert all(x -&gt; isapprox(x, 0, atol = 1e-4), sol.u[end]) # ensure state converges to zero

julia&gt; controlcalls[]
1001</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/d0b457b033740a9bc1c29e80c6c33ef1cca84c03/src/control.jl#L25-L94">source</a></section><h2><a class="nav-anchor" id="Visualization-1" href="#Visualization-1">Visualization</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiffEqBase.CallbackSet-Tuple{DrakeVisualizer.Visualizer,RigidBodyDynamics.MechanismState}" href="#DiffEqBase.CallbackSet-Tuple{DrakeVisualizer.Visualizer,RigidBodyDynamics.MechanismState}"><code>DiffEqBase.CallbackSet</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">CallbackSet(vis, state; max_fps)
</code></pre><p>Create the DifferentialEquations.jl callbacks needed for publishing to and receiving commands from a <a href="https://github.com/RobotLocomotion/director">director</a> visualizer instance during simulation.</p><p><code>max_fps</code> is the maximum number of frames per second (in terms of wall time) to draw. Default: <code>60.0</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/d0b457b033740a9bc1c29e80c6c33ef1cca84c03/src/visualization.jl#L113-L118">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodySim.Visualization.any_open_visualizer_windows" href="#RigidBodySim.Visualization.any_open_visualizer_windows"><code>RigidBodySim.Visualization.any_open_visualizer_windows</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">any_open_visualizer_windows()
</code></pre><p>Return whether any <a href="https://github.com/RobotLocomotion/director">director</a> visualizer windows are open.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/d0b457b033740a9bc1c29e80c6c33ef1cca84c03/src/visualization.jl#L124-L126">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodySim.Visualization.new_visualizer_window" href="#RigidBodySim.Visualization.new_visualizer_window"><code>RigidBodySim.Visualization.new_visualizer_window</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">new_visualizer_window()
</code></pre><p>Open a new <a href="https://github.com/RobotLocomotion/director">director</a> visualizer window.</p><p>The director instance will be started with a script that handles communication between RigidBodySim.jl and the director instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/d0b457b033740a9bc1c29e80c6c33ef1cca84c03/src/visualization.jl#L129-L134">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodySim.Visualization.animate-Tuple{DrakeVisualizer.Visualizer,RigidBodyDynamics.MechanismState,DiffEqBase.ODESolution}" href="#RigidBodySim.Visualization.animate-Tuple{DrakeVisualizer.Visualizer,RigidBodyDynamics.MechanismState,DiffEqBase.ODESolution}"><code>RigidBodySim.Visualization.animate</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">animate(vis, state, sol; max_fps, realtime_rate, pause_pollint)
</code></pre><p>Play back a visualization of a <code>DiffEqBase.ODESolution</code> obtained from a RigidBodySim.jl simulation.</p><p><code>vis</code> is a <code>DrakeVisualizer.Visualizer</code>. The easiest way to create a <code>Visualizer</code> for a robot is from a URDF, which can be parsed by <a href="https://github.com/rdeits/RigidBodyTreeInspector.jl">RigidBodyTreeInspector.jl</a>&#39;s <code>parse_urdf</code> function.</p><p><code>state</code> is a <a href="http://JuliaRobotics.github.io/RigidBodyDynamics.jl/release-0.4/mechanismstate.html#RigidBodyDynamics.MechanismState"><code>RigidBodyDynamics.MechanismState</code></a>, representing the state of the mechanism that was simulated, and will be modified during the visualization.</p><p><code>animate</code> accepts the following keyword arguments:</p><ul><li><p><code>max_fps</code>: the maximum number of frames per second to draw. Default: <code>60.0</code>.</p></li><li><p><code>realtime_rate</code>: can be used to slow down or speed up playback compared to wall time. A <code>realtime_rate</code> of <code>2</code> will result in playback that is sped up 2x. Default: <code>1.0</code>.</p></li><li><p><code>pause_pollint</code>: how often to poll for commands coming from the director window when playback is paused. Default: 0.05.</p></li></ul><p><strong>Examples</strong></p><p>Visualizing the result of a simulation of the passive dynamics of an Acrobot (double pendulum) at half speed:</p><pre><code class="language-julia-repl">julia&gt; using RigidBodySim, RigidBodyDynamics, OrdinaryDiffEq, RigidBodyTreeInspector

julia&gt; urdf = Pkg.dir(&quot;RigidBodySim&quot;, &quot;test&quot;, &quot;urdf&quot;, &quot;Acrobot.urdf&quot;);

julia&gt; mechanism = parse_urdf(Float64, urdf);

julia&gt; state = MechanismState(mechanism);

julia&gt; set_configuration!(state, [0.1; 0.2]);

julia&gt; problem = ODEProblem(state, (0., 2.));

julia&gt; sol = solve(problem, Vern7());

julia&gt; any_open_visualizer_windows() || (new_visualizer_window(); sleep(1));

julia&gt; vis = Visualizer(mechanism, parse_urdf(urdf, mechanism));

julia&gt; animate(vis, state, sol; realtime_rate = 0.5);</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/d0b457b033740a9bc1c29e80c6c33ef1cca84c03/src/visualization.jl#L137-L178">source</a></section><h2><a class="nav-anchor" id="Utilities-1" href="#Utilities-1">Utilities</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodySim.Core.configuration_renormalizer" href="#RigidBodySim.Core.configuration_renormalizer"><code>RigidBodySim.Core.configuration_renormalizer</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">configuration_renormalizer(state)
configuration_renormalizer(state, condition)
</code></pre><p><code>configuration_renormalizer</code> can be used to create a callback that projects the configuration of a mechanism&#39;s state onto the configuration manifold. This may be necessary for mechanism&#39;s with e.g. quaternion-parameterized orientations as part of their joint configuration vectors, as numerical integration can cause the configuration to drift away from the unit norm constraints.</p><p>The callback is implemented as a <a href="http://docs.juliadiffeq.org/release-4.0/features/callback_functions.html#DiscreteCallback-1"><code>DiffEqCallbacks.DiscreteCallback</code></a> By default, it is called at every integrator time step.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaRobotics/RigidBodySim.jl/blob/d0b457b033740a9bc1c29e80c6c33ef1cca84c03/src/core.jl#L114-L122">source</a></section><footer><hr/><a class="previous" href="quickstart.html"><span class="direction">Previous</span><span class="title">Quick start guide</span></a></footer></article></body></html>
